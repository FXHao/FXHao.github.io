---
layout: post
title: "MySQL高级"
date: 2019-05-13
description: "MySQL数据库"
tag: MySQL数据库
---


## MySQL高级

### 视图

> 通俗的讲，视图就是一条**SELECT**语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

> 视图是对若干张基本表的引用，一张虚拟的表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性；

* **定义视图**

  ```python
  create view 视图名称 as select语句;  # 名称建议以  v_  开头
  ```

* **使用视图** 时，因为视图本身就是一张表，只不过是一张虚的表，所以操作表对应的语句去操作视图，  用 `show tables;` 查看现有的视图，用 `select * from 视图名;` 去查询

* **删除视图**  

  ```python
  drop view 视图名称;
  ```

* **作用**

  > 1.提高了重用性，就像一个函数
  > 2.对数据库重构，却不影响程序的运行
  > 3.提高了安全性能，可以对不同的用户
  > 4.让数据更加清晰

------

### 事务

* 所谓事务，就相当于把某些操作打包成一个**整体** ，而这个整体里的内容在执行时要么都被执行，要么都不执行

  > 就好比银行的转账工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性

#### **事务的四大特性(ACID)**

* **原子性(Atomicity)**

  > 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

* **一致性(Consistency)**

  > 数据库总是从一个一致性的状态转换到另一个一致性的状态。（就如在转账中，一致性确保了，即使在执行减钱与加钱之间时系统崩溃，支票账户中也不会损失，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

* **隔离性(Isolation)**

  > 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（就像在转账中，当执行完减钱语句、加钱语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去）

* **持久性(Durability)**

  > 一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。）

#### **事务的使用**

* **开启事务** 后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中

  ```sql
  begin;
  -- 或者
  start transaction;
  ```

* **提交事务**:将缓存中的数据变更维护到物理表中

  ```sql
  commit;
  ```

* **回滚事务**：放弃缓存中变更的数据

  ```sql
  rollback;
  ```

#### 注意

> * 终端里修改数据库的命令是默认自动开启事务的，即在修改命令语句前相当于有一个`begin` 修改命令语句后 有一个 `commit`  
> * 手动开启事务可以进行多次数据的修改，如果成功则一起成功，否则一起回滚修改前的数据，在python中操作数据库，是要手动开启事务的

### 索引

* 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

  更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度

* **原理**

  > 数据库跟字典一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。

  ![](https://FXHao.github.io/images/posts/MySQL/索引.jpg)

* **使用**

  * 查看索引

    ```sql
    show index from 表名;
    ```

  * 创建索引

    * 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致
    * 字段类型如果不是字符串，可以不填写长度部分

    ```sql
    create index 索引名称 on 表名(字段名称(长度))
    ```

  * 删除索引

    ```sql
    drop index 索引名称 on 表名;
    ```

* 注意

  > 要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。
  >
  > 建立索引会占用磁盘空间

### 账户管理

* 额。。这玩意一般是权限最高的用来分配权限的

### MySQL主从

* 这东西 用到时在查吧。

* 简单说下好处

  > - 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。
  > - 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据
  > - 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

**END....**